<!doctype html>
<html class="no-js" lang="zh_CN">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="索引" href="../genindex.html" /><link rel="search" title="搜索" href="../search.html" /><link rel="prev" title="阅读笔记" href="daily.html" />

    <meta name="generator" content="sphinx-4.3.2, furo 2022.06.21"/>
        <title>seL4 - Notes</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=40978830699223671f4072448e654b5958f38b89" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #7C4DFF;
  --color-brand-content: #7C4DFF;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">Notes</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">Notes</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder=搜索 name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 has-children"><a class="reference internal" href="../papers/index.html">论文阅读</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../papers/theseus.html">Theseus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../papers/unikraft.html">Unikraft</a></li>
<li class="toctree-l2"><a class="reference internal" href="../papers/redleaf.html">Redleaf</a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">其他</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="loongson.html">龙芯杯比赛回顾</a></li>
<li class="toctree-l2"><a class="reference internal" href="wifi.html">破解 WIFI</a></li>
<li class="toctree-l2"><a class="reference internal" href="s7.html">启动 S7 核</a></li>
<li class="toctree-l2"><a class="reference internal" href="rust.html">学习 Rust</a></li>
<li class="toctree-l2"><a class="reference internal" href="uint.html">User Interrupt</a></li>
<li class="toctree-l2"><a class="reference internal" href="daily.html">阅读笔记</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">seL4</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="edit-this-page">
  <a class="muted-link" href="https://github.com/tkf2019/Blog/edit/main/source/others/seL4.md" title="Edit this page">
    <svg aria-hidden="true" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
      <line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
    </svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <div class="section" id="sel4">
<h1>seL4<a class="headerlink" href="#sel4" title="永久链接至标题">#</a></h1>
<p>本文档的分析主要基于 RISC-V 架构。</p>
<div class="section" id="tutorial">
<h2>Tutorial<a class="headerlink" href="#tutorial" title="永久链接至标题">#</a></h2>
<p>seL4 构建基于多种工具，包括 repo、ninja 等。Tutorial 测例默认在 x86 架构的 QEMU 上运行。</p>
<p>运行 hello-world 退出后报错 <code class="docutils literal notranslate"><span class="pre">Caught</span> <span class="pre">cap</span> <span class="pre">fault</span></code>，将 return 0 改为执行 exit 后不再出现报错。</p>
<p>ninja 构建 hello-camkes-0 报错 <code class="docutils literal notranslate"><span class="pre">make:</span> <span class="pre">stack:</span> <span class="pre">No</span> <span class="pre">such</span> <span class="pre">file</span> <span class="pre">or</span> <span class="pre">directory</span></code>，一个解决办法是执行 <code class="docutils literal notranslate"><span class="pre">curl</span> <span class="pre">-sSL</span> <span class="pre">https://get.haskellstack.org/</span> <span class="pre">|</span> <span class="pre">sh</span></code> 安装 haskell-stack，然后报错 Timeout，解决网络问题后可以正常运行。</p>
</div>
<div class="section" id="hardware">
<h2>Hardware<a class="headerlink" href="#hardware" title="永久链接至标题">#</a></h2>
<p>支持 <a class="reference external" href="https://docs.sel4.systems/Hardware/rocketchip.html">Rocket</a> 硬件平台。</p>
<p>hardware.yml 给出的硬件描述，以 uintc 为例：</p>
<div class="highlight-yml notranslate"><div class="highlight"><pre><span></span>- compatible:
    - riscv,uintc0
  regions:
    - index: 0
      kernel: UINTC_PPTR
      kernel_size: 0x4000
      user: true
</pre></div>
</div>
<p>其中 kernel 字段表示内核映射后的 device 起始地址。</p>
</div>
<div class="section" id="capability">
<h2>Capability<a class="headerlink" href="#capability" title="永久链接至标题">#</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A capability is a unique, unforgeable token that gives the possessor permission to access an entity or object in system. 
</pre></div>
</div>
<p><strong>Capability (cap)</strong> 是 seL4 的核心机制，通过唯一且不可伪造的 token 来获取对象的访问权限，可以将 cap 视为带有访问控制的指针。</p>
<p><strong>root task</strong> 在初始化时会获取所有资源的 cap ，例如 <code class="docutils literal notranslate"><span class="pre">seL4_CapInitThreadTCB</span></code>，可以通过 API 读取或修改 TCB 的内容。</p>
<p><strong>CSpace</strong> 表示一个 thread 持有的全部 cap 。</p>
<p><strong>CNodes &amp; CSlots</strong>：可以将 CNode 视为 cap 数组，数组元素被称为 CSlot ，CSlot 可以看成是 <code class="docutils literal notranslate"><span class="pre">Option&lt;Cap&gt;</span></code> 类型。<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">info-&gt;CNodeSizeBits</span></code> 表示数组大小，<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">seL4_SlotBits</span></code> 表示 CSlot 大小。每个 thread 的 TCB 中有一个 CNode cap ，即 CSpace root 。Invocation 会隐式地通过 CSpace root 访问 CNode ，并通过其中的 CSlot 访问资源。可以通过以下字段寻址 CSlot：</p>
<ul class="simple">
<li><p>_service/root：对应的 CNode cap</p></li>
<li><p>index：CSlot 在 CNode 中的下标</p></li>
<li><p>depth：默认为 <code class="docutils literal notranslate"><span class="pre">seL4_WordBits</span></code> （寻址 <code class="docutils literal notranslate"><span class="pre">index</span> <span class="pre">&lt;&lt;</span> <span class="pre">seL4_WordBits</span></code>）</p></li>
</ul>
<p>以 root task 为例， 访问 TCB 的过程大致为 <code class="docutils literal notranslate"><span class="pre">seL4_CapInitThreadCNode</span> <span class="pre">-&gt;</span> <span class="pre">CNode</span> <span class="pre">-&gt;</span> <span class="pre">seL4_CapInitThreadTCB</span> <span class="pre">-&gt;</span> <span class="pre">TCB</span></code> 。<code class="docutils literal notranslate"><span class="pre">seL4_bootInfo</span></code> 描述了初始 CSpace 中的 cap 和空闲 CSlot 。</p>
</div>
<div class="section" id="tcb">
<h2>TCB<a class="headerlink" href="#tcb" title="永久链接至标题">#</a></h2>
<p>从 <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tcb</span></code> 出发，分析其成员的含义：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">arch_tcb_t</span> <span class="pre">tcbArch</span></code>：arch 相关的状态，主要包含上下文的内容。逐级展开可以的得到 <code class="docutils literal notranslate"><span class="pre">word_t</span> <span class="pre">registers[n_contextRegisters]</span></code>，相关定义位于 <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">_register</span></code>，除了 31 个通用寄存器外（不包括 zero），还包含 <code class="docutils literal notranslate"><span class="pre">sstatus</span></code> 和 <code class="docutils literal notranslate"><span class="pre">scause</span></code> 等，可以在其中加入其他需要保存和恢复的用户态寄存器。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">thread_state_t</span> <span class="pre">tcbState</span></code>：线程状态，主要包括：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">ThreadState_Inactive</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ThreadState_Running</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ThreadState_Restart</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ThreadState_BlockedOnReceive</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ThreadState_BlockedOnSend</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ThreadState_BlockedOnReply</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ThreadState_BlockedOnNotification</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">notification_t</span> <span class="pre">*tcbBoundNotification</span></code>：指向该线程对应的 Notification ，若该指针非空，该线程可以接收 Signalsh ceshce</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">seL4_Fault_t</span> <span class="pre">tcbFault</span></code>：</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lookup_fault_t</span> <span class="pre">tcbLookupFailure</span></code>：</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dom_t</span> <span class="pre">tcbDomain</span></code>：</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prio_t</span> <span class="pre">tcbMCP</span></code>：</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prio_t</span> <span class="pre">tcbPriority</span></code>：线程优先级</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sched_context_t</span> <span class="pre">*tcbSchedContext</span></code>：该线程对应的调度上下文，若该指针为空，线程不可被加入调度队列</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sched_context_t</span> <span class="pre">*tcbYieldTo</span></code>：线程切换至的调度上下文</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">word_t</span> <span class="pre">tcbIPCBuffer</span></code>：用户空间的 IPC 缓冲区的虚拟地址</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">word_t</span> <span class="pre">tcbAffinity</span></code>：正在运行该线程的核号</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tcb</span> <span class="pre">*tcbSchedNext,</span> <span class="pre">*tcbSchedPrev</span></code>：调度队列的链表指针</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tcb</span> <span class="pre">*tcbEPNext,</span> <span class="pre">*tcbEPPrev</span></code>：Notification 队列的链表指针</p></li>
</ul>
<p>实际的 TCB 还包括头部的 <code class="docutils literal notranslate"><span class="pre">cte_t</span></code> ，<code class="docutils literal notranslate"><span class="pre">tcb_t</span></code> 默认占据 TCB 的后半部分空间。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// A diagram of a TCB kernel object that is created from untyped:</span>
<span class="c1">//  _______________________________________</span>
<span class="c1">// |     |             |                   |</span>
<span class="c1">// |     |             |                   |</span>
<span class="c1">// |cte_t|   unused    |       tcb_t       |</span>
<span class="c1">// |     |(debug_tcb_t)|                   |</span>
<span class="c1">// |_____|_____________|___________________|</span>
<span class="c1">// 0     a             b                   c</span>
<span class="c1">// a = tcbCNodeEntries * sizeof(cte_t)</span>
<span class="c1">// b = BIT(TCB_SIZE_BITS)</span>
<span class="c1">// c = BIT(seL4_TCBBits)</span>
</pre></div>
</div>
<p>常用内核函数：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">tcbEPDequeue(tcb_t</span> <span class="pre">*tcb,</span> <span class="pre">tcb_queue_t</span> <span class="pre">queue)</span></code>：将当前 TCB 从队列（EP 或 Ntfn 的等待队列）中移除</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cpu_id_t</span> <span class="pre">getCurrentCPUIndex(void)</span></code>：从 <code class="docutils literal notranslate"><span class="pre">sscratch</span></code> 寄存器中读出当前核号</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">tcbSchedEnqueue(tcb_t</span> <span class="pre">*tcb)</span></code>：将 TCB 置于调度队列的头部</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">tcbSchedAppend(tcb_t</span> <span class="pre">*tcb)</span></code>：将 TCB 置于调度队列的头部</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">remoteQueueUpdate(tcb_t</span> <span class="pre">*tcb)</span></code>：发送 <code class="docutils literal notranslate"><span class="pre">ipiReschedulePending</span></code> 更新目标核的调度目标</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">setRegister(tcb_t</span> <span class="pre">*thread,</span> <span class="pre">register_t</span> <span class="pre">reg,</span> <span class="pre">word_t</span> <span class="pre">w)</span></code>：设置寄存器<code class="docutils literal notranslate"><span class="pre">thread-&gt;tcbArch.tcbContext.registers[reg]</span> <span class="pre">=</span> <span class="pre">w</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NODE_STATE(ksCurThread)</span></code>：获取当前正在运行的 TCB （多用于系统调用）</p></li>
</ul>
</div>
<div class="section" id="mcs">
<h2>MCS<a class="headerlink" href="#mcs" title="永久链接至标题">#</a></h2>
</div>
<div class="section" id="ipc">
<h2>IPC<a class="headerlink" href="#ipc" title="永久链接至标题">#</a></h2>
<blockquote>
<div><p><a class="reference external" href="https://microkerneldude.org/2019/03/07/how-to-and-how-not-to-use-sel4-ipc/">这篇文章</a>辨析了 seL4 IPC 机制。</p>
</div></blockquote>
<p>seL4 中的 IPC 机制可以在线程之间传递消息（<strong>endpoint</strong>结构），也可以让线程和内核服务进行通信（其他内核结构）。IPC 传递的消息被保存在 Message Register 中（简称 MR），如果消息长度较短，可直接通过物理寄存器来传递，否则使用 IPC buffer 。消息的元结构为 <code class="docutils literal notranslate"><span class="pre">seL4_MessageInfo_t</span></code> ，包含以下字段：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block</span> <span class="n">seL4_MessageInfo</span> <span class="p">{</span>
    <span class="n">field</span> <span class="n">label</span> <span class="mi">52</span>        <span class="o">//</span> <span class="n">原始信息</span>
    <span class="n">field</span> <span class="n">capsUnwrapped</span> <span class="mi">3</span> <span class="o">//</span> 
    <span class="n">field</span> <span class="n">extraCaps</span> <span class="mi">2</span>     <span class="o">//</span> <span class="n">cap</span> <span class="n">数量</span>
    <span class="n">field</span> <span class="n">length</span> <span class="mi">7</span>        <span class="o">//</span> <span class="n">消息长度</span>
<span class="p">}</span>
</pre></div>
</div>
<p>IPC buffer 结构包含以下字段：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">seL4_IPCBuffer_</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">seL4_MessageInfo_t</span><span class="w"> </span><span class="n">tag</span><span class="p">;</span><span class="w">           </span><span class="c1">// 元信息</span>
<span class="w">    </span><span class="n">seL4_Word</span><span class="w"> </span><span class="n">msg</span><span class="p">[</span><span class="n">seL4_MsgMaxLength</span><span class="p">];</span><span class="w"> </span><span class="c1">// 消息内容</span>
<span class="w">    </span><span class="n">seL4_Word</span><span class="w"> </span><span class="n">userData</span><span class="p">;</span><span class="w">               </span><span class="c1">// 该结构起始地址</span>
<span class="w">    </span><span class="c1">// 发送的 cap 或标识符</span>
<span class="w">    </span><span class="n">seL4_Word</span><span class="w"> </span><span class="n">caps_or_badges</span><span class="p">[</span><span class="n">seL4_MsgMaxExtraCaps</span><span class="p">];</span>
<span class="w">    </span><span class="c1">// 以下结构用于定位接收 cap 的 slot</span>
<span class="w">    </span><span class="n">seL4_CPtr</span><span class="w"> </span><span class="n">receiveCNode</span><span class="p">;</span>
<span class="w">    </span><span class="n">seL4_CPtr</span><span class="w"> </span><span class="n">receiveIndex</span><span class="p">;</span>
<span class="w">    </span><span class="n">seL4_Word</span><span class="w"> </span><span class="n">receiveDepth</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">seL4_IPCBuffer</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">seL4_IPCBuffer_</span><span class="p">))));</span>
</pre></div>
</div>
<p>内核结构包含以下字段：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>block endpoint {
    field epQueue_head 64       // 等待队列头部
    field_high epQueue_tail 37  // 等待队列尾部
    field state 2               // 当前状态
}

block endpoint_cap {
    field capEPBadge 64          // 标识符，非0标识符不可被修改
    field capType 5              // cap 类型
    field capCanGrantReply 1     //  
    field capCanGrant 1          //
    field capCanReceive 1        // 可以接收
    field capCanSend 1           // 可以发送
    field_high capEPPtr 39       // 指向 endpoint 内核结构
}

block reply_cap {
    field capTCBPtr 64           // 指向绑定的 TCB 
    field capType 5              // cap 类型
    field capReplyCanGrant 1     // 源自 endpoint_cap 的 capCanGrant 字段
#ifndef CONFIG_KERNEL_MCS
    field capReplyMaster 1
#endif
}
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">state</span></code> 字段指定 EP 的三种状态：</p>
<ul class="simple">
<li><p><strong>EPState_Send</strong>：等待队列中有 TCB 等待发送</p></li>
<li><p><strong>EPState_Recv</strong>：等待队列中有 TCB 等待接收</p></li>
<li><p><strong>EPState_Idle</strong>：等待队列为空</p></li>
</ul>
<p>IPC 的发送与接收都是阻塞的，也就是说当调用 <code class="docutils literal notranslate"><span class="pre">seL4_Send</span></code> 或 <code class="docutils literal notranslate"><span class="pre">seL4_Call</span></code> 时如果没有接收方，发送方会进入等待队列；当调用 <code class="docutils literal notranslate"><span class="pre">seL4_Recv</span></code> 和 <code class="docutils literal notranslate"><span class="pre">seL4_ReplyRecv</span></code> 时如果没有发送方，接收方会进入等待队列。无写权限的 Send 和 Call 不会触发错误，但是有读权限的 Recv 会触发 <code class="docutils literal notranslate"><span class="pre">seL4_Fault_*</span></code> 错误。IPC 可以发送 cap ，但 sender 必须有 Grant 权限。如果发送了表示内核结构的 cap ，这些额外的 cap 会被标记在 tag 的 capsUnwrapped 字段，只有 badge 被发送，这样接收方的 slot 可以用来保存其他 cap 。</p>
<p>将一次 IPC 发送或接收看成一次事务，该事务是非原子的。也就是说错误发生前的操作可以被正常完成，错误后的操作会被中止。</p>
<p>reply_cap 在发送方调用 <code class="docutils literal notranslate"><span class="pre">seL4_Call</span></code> 时自动生成，其中的 capTCBPtr 字段指向发送方。可以通过 seL4_Reply 直接调用 reply_cap ，也可以通过 seL4_CNode_SaveCaller 将该 cap 保存在其他 slot ，这样可以之后通过 seL4_Send 进行调用。capReplyCanGrant 字段表示是否可以通过 reply_cap 在回复的消息中发送 cap 。对于 reply_cap 的调用一定是非阻塞的，也就是说一定指向某个正在等待回复的 sender 。caller 接收回复的消息和 seL4_Recv 的流程类似。</p>
<p>内核相关函数：</p>
<blockquote>
<div><p>注：内核函数参数类型为 <code class="docutils literal notranslate"><span class="pre">tcb_t</span> <span class="pre">*</span></code> 时名称却不一样，下面统一为 <code class="docutils literal notranslate"><span class="pre">tcb_t</span> <span class="pre">*tcb</span></code></p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">sendIPC(bool_t</span> <span class="pre">blocking,</span> <span class="pre">bool_t</span> <span class="pre">do_call,</span> <span class="pre">word_t</span> <span class="pre">badge,</span> <span class="pre">bool_t</span> <span class="pre">canGrant,</span> <span class="pre">bool_t</span> <span class="pre">canGrantReply,</span> <span class="pre">tcb_t</span> <span class="pre">*tcb,</span> <span class="pre">endpoint_t</span> <span class="pre">*epptr)</span></code>：不同的状态处理方法不同：</p>
<ul>
<li><p>EPState_Idle 和 EPState_Send：如果指定为 blocking ，则将当前 TCB 状态设置为 ThreadState_BlockingOnSend，并设置 blockingObject、blockingIPCBadge、blockingIPCCanGrant、blockingIPCCanGrantReply、blockingIPCIsCall 属性，将该 TCB 放入 EP 等待队列中</p></li>
<li><p>EPState_Recv：从等待队列头部取出 TCB ，若此时等待队列为空，则转为 EPState_Idle ；调用 <code class="docutils literal notranslate"><span class="pre">doIPCTransfer</span></code>；如果是 IPC Call ，通过 <code class="docutils literal notranslate"><span class="pre">setupCallerCap</span></code> 创建 reply_cap ，否则将目标 TCB 的状态设置为 <code class="docutils literal notranslate"><span class="pre">ThreadState_Running</span></code> 并进行调度</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">receiveIPC(tcb_t</span> <span class="pre">*tcb,</span> <span class="pre">cap_t</span> <span class="pre">cap,</span> <span class="pre">bool_t</span> <span class="pre">isBlocking)</span></code>：首先检查 TCB 是否有待接收的 Signal ，如果有则优先调用 <code class="docutils literal notranslate"><span class="pre">completeSignal</span></code> （Signal 是消息长度为 0 的 IPC）；不同的状态处理方法不同：</p>
<ul>
<li><p>EPState_Idle 和 EPState_Recv：如果指定为 blocking ，则将当前 TCB 状态设置为 ThreadState_BlockingOnReceive，设置 blockingObject 和 blokcingIPCCanGrant ，将 TCB 加入 EP 的等待队列中，状态转为 EPState_Recv</p></li>
<li><p>EPState_Send：从等待队列头部取出 sender ，如果等待队列为空，转为 EPState_Idle 状态；获取 sender 保存的 badge，canGrant，canGrantReply 信息，调用 <code class="docutils literal notranslate"><span class="pre">doIPCTransfer</span></code>；如果是 IPC Call ，通过 <code class="docutils literal notranslate"><span class="pre">setupCallerCap</span></code> 创建 reply_cap ，否则将目标 TCB 的状态设置为 <code class="docutils literal notranslate"><span class="pre">ThreadState_Running</span></code> 并进行调度</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">cancelIPC(tcb_t</span> <span class="pre">*tcb)</span></code>：根据 TCB 状态进行判断：</p>
<ul>
<li><p>ThreadState_BlockOnSend 和 ThreadState_BlockOnReceive：从等待队列中移除该 TCB ，并将 TCB 状态设置为 ThreadState_Inactive</p></li>
<li><p>ThreadState_BlockedOnNotification：调用 <code class="docutils literal notranslate"><span class="pre">cancelSignal</span></code></p></li>
<li><p>ThreadState_BlockedOnReply：移除 reply_cap</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">cancelAllIPC(endpoint_t</span> <span class="pre">*epptr)</span></code>：状态转为 EPState_Idle ，清空等待队列，将其中所有 TCB 加入调度队列，状态设置为 ThreadState_Restart</p></li>
</ul>
</div>
<div class="section" id="notification">
<h2>Notification<a class="headerlink" href="#notification" title="永久链接至标题">#</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block</span> <span class="n">notification</span> <span class="p">{</span>
<span class="c1">#ifdef CONFIG_KERNEL_MCS</span>
    <span class="n">field_high</span> <span class="n">ntfnSchedContext</span> <span class="mi">39</span>
<span class="c1">#endif</span>
    <span class="n">field_high</span> <span class="n">ntfnBoundTCB</span> <span class="mi">39</span>      <span class="o">//</span> <span class="n">指向绑定的</span> <span class="n">TCB</span>
    <span class="n">field</span> <span class="n">ntfnMsgIdentifier</span> <span class="mi">64</span>      <span class="o">//</span> <span class="n">msg</span> <span class="n">标识符</span>
    <span class="n">field_high</span> <span class="n">ntfnQueue_head</span> <span class="mi">39</span>    <span class="o">//</span> <span class="n">等待队列头部</span>
    <span class="n">field_high</span> <span class="n">ntfnQueue_tail</span> <span class="mi">39</span>    <span class="o">//</span> <span class="n">等待队列尾部</span>
    <span class="n">field</span> <span class="n">state</span> <span class="mi">2</span>                   <span class="o">//</span> <span class="n">当前状态</span>
<span class="p">}</span>

<span class="n">block</span> <span class="n">notification_cap</span> <span class="p">{</span>
    <span class="n">field</span> <span class="n">capNtfnBadge</span> <span class="mi">64</span>      <span class="o">//</span> <span class="n">badge</span> <span class="n">标识符</span>
    <span class="n">field</span> <span class="n">capType</span> <span class="mi">5</span>            <span class="o">//</span> <span class="n">cap</span> <span class="n">类型</span>
    <span class="n">field</span> <span class="n">capNtfnCanReceive</span> <span class="mi">1</span>  <span class="o">//</span> <span class="n">可以接收</span>
    <span class="n">field</span> <span class="n">capNtfnCanSend</span> <span class="mi">1</span>     <span class="o">//</span> <span class="n">可以发送</span>
    <span class="n">field_high</span> <span class="n">capNtfnPtr</span> <span class="mi">39</span>   <span class="o">//</span> <span class="n">指向</span> <span class="n">notification</span> <span class="n">内核结构</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">state</span></code> 字段指定 Notification 的三种状态：</p>
<ul class="simple">
<li><p><strong>NtfnState_Waiting</strong>：TCB 在队列中等待接收信号</p></li>
<li><p><strong>NtfnState_Active</strong>：TCB 接收到信号但等待队列为空</p></li>
<li><p><strong>NtfnState_Idle</strong>：以上两种状态之外的状态</p></li>
</ul>
<p>内核相关函数：</p>
<blockquote>
<div><p>注：内核函数参数类型为 <code class="docutils literal notranslate"><span class="pre">tcb_t</span> <span class="pre">*</span></code> 时名称却不一样，下面统一为 <code class="docutils literal notranslate"><span class="pre">tcb_t</span> <span class="pre">*tcb</span></code></p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">bindNotification(tcb_t</span> <span class="pre">*tcb,</span> <span class="pre">notification_t</span> <span class="pre">*ntfnPtr)</span></code>：将 notification 绑定到指定的 TCB ，将 ntfnPtr 赋值给 tcbBoundNotification ，将 tcb 赋值给 ntfnBoundTCB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">unbindNotification(tcb_t</span> <span class="pre">*tcb)</span></code>：取消绑定</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">sendSignal(notification_t</span> <span class="pre">*ntfnPtr,</span> <span class="pre">word_t</span> <span class="pre">badge)</span></code>：不同的状态处理方法不同：</p>
<ul>
<li><p>NtfnState_Idle：如果绑定到 TCB ，则根据 TCB 当前状态进行判断，若处于 ThreadState_BlockedOnReceive ，切换到该 TCB 开始运行，并设置 badge 标识符，否则转为 NtfnState_Active 状态</p></li>
<li><p>NtfnState_Waiting：从等待队列中取出一个唤醒并开始执行，如果队列变为空则转为 NtfnState_Idle 状态</p></li>
<li><p>NtfnState_Active：已经有正在等待响应的 badge 了，直接与当前 badge 进行或操作</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">receiveSignal(tcb_t</span> <span class="pre">*tcb,</span> <span class="pre">cap_t</span> <span class="pre">cap,</span> <span class="pre">bool_t</span> <span class="pre">isBlocking)</span></code>：根据 cap 获取 Notification 对象指针，不同状态的处理方法不同：</p>
<ul>
<li><p>NtfnState_Idle 和 NtfnState_Waiting：若采用阻塞方法（isBlocking 为 1），则设置 TCB 状态为 ThreadState_BlockedOnNotification ，并设置 TCB 的 blockingObject 为当前 ntfnPtr ，将 TCB 放到 Ntfn 等待队列尾部等待唤醒，转为 NtfnState_Waiting 状态</p></li>
<li><p>NtfnState_Active：将 TCB 的 badgeRegister 设置为 ntfnMsgIdentifier ，转为 NtfnState_Idle 状态</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">cancelSignal(tcb_t</span> <span class="pre">*tcb,</span> <span class="pre">notification_t</span> <span class="pre">*ntfnPtr)</span></code>：将 TCB 从 Ntfn 等待队列中移除，若等待队列为空则转为 NtfnState_Idle 状态，将 TCB 当前状态设置为 ThreadState_Inactive</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">completeSignal(notification_t</span> <span class="pre">*ntfnPtr,</span> <span class="pre">tcb_t</span> <span class="pre">*tcb)</span></code>：若当前状态为 NtfnState_Active ，则
设置对应 tcb 的 badge 寄存器，转为 NtfnState_Idle</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">cancelAllSignals(notification_t</span> <span class="pre">*ntfnPtr)</span></code>：状态转为 NtfnState_Idle ，清空等待队列，将其中所有 TCB 加入调度队列，状态设置为 ThreadState_Restart</p></li>
</ul>
</div>
<div class="section" id="irq">
<h2>IRQ<a class="headerlink" href="#irq" title="永久链接至标题">#</a></h2>
<p>相关 Cap 如下：</p>
<ul class="simple">
<li><p><strong>IRQControl</strong>：由 root 进行管理，不可被复制</p></li>
<li><p><strong>IRQHandler</strong>：通过调用 IRQControl 获取对应中断的访问权限，可以被复制；通过 <code class="docutils literal notranslate"><span class="pre">seL4_IRQControl_Get(seL4_IRQControl</span> <span class="pre">_service,</span> <span class="pre">seL4_Word</span> <span class="pre">irq,</span> <span class="pre">seL4_CNode</span> <span class="pre">root,</span> <span class="pre">seL4_Word</span> <span class="pre">index,</span> <span class="pre">seL4_Uint8</span> <span class="pre">depth)</span></code> 获取</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">seL4_IRQHandler_SetNotification</span></code> 将 IRQHandler 绑定至 Notification 接收中断，如果想让 Notification 接收多个中断，可以让 badge 绑定至不同的 IRQHandler 。中断可以通过 <code class="docutils literal notranslate"><span class="pre">seL4_Poll</span></code> 或 <code class="docutils literal notranslate"><span class="pre">seL4_Wait</span></code> 来感知。通过 Notification 接收中断并进行处理后，可以通过 <code class="docutils literal notranslate"><span class="pre">seL4_IRQHandler_Ack</span></code> 来响应中断（准备接收下一个中断）或 <code class="docutils literal notranslate"><span class="pre">seL4_IRQHandler_Clear</span></code> 来取消绑定。</p>
</div>
<div class="section" id="boot">
<h2>Boot<a class="headerlink" href="#boot" title="永久链接至标题">#</a></h2>
<p>从 <code class="docutils literal notranslate"><span class="pre">head.S</span></code> 入手分析 kernel 的启动流程：</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span>  /* Call bootstrapping implemented in C with parameters:
   *    a0/x10: user image physical start address
   *    a1/x11: user image physical end address
   *    a2/x12: physical/virtual offset
   *    a3/x13: user image virtual entry address
   *    a4/x14: DTB physical address (0 if there is none)
   *    a5/x15: DTB size (0 if there is none)
   *    a6/x16: hart ID (SMP only, unused on non-SMP)
   *    a7/x17: core ID (SMP only, unused on non-SMP)
   */
_start:
  fence.i
.option push
.option norelax
1:auipc gp, %pcrel_hi(__global_pointer$)
  addi  gp, gp, %pcrel_lo(1b)
.option pop

/* 多核下为每个核分配栈空间 */
  la sp, (kernel_stack_alloc + BIT(CONFIG_KERNEL_STACK_BITS))
  csrw sscratch, x0 /* zero sscratch for the init task */
#if CONFIG_MAX_NUM_NODES &gt; 1
  mv t0, a7
  slli t0, t0, CONFIG_KERNEL_STACK_BITS
  add  sp, sp, t0
  csrw sscratch, sp
#endif
  /* 内核初始化 */
  jal init_kernel
  /* 恢复用户态上下文（返回到 root） */
  la ra, restore_user_context
  jr ra

</pre></div>
</div>
</div>
<div class="section" id="syscalls">
<h2>Syscalls<a class="headerlink" href="#syscalls" title="永久链接至标题">#</a></h2>
<p>可在<a class="reference external" href="https://docs.sel4.systems/projects/sel4/api-doc.html">官网</a>查看 API 说明，相关定义位于 libsel4/include/api/syscall.xml 。</p>
<p>seL4 riscv 的 syscall 实现位于 libsel4/arch_include/riscv/sel4/arch/syscalls.h ，对上暴露的 API 保持一致，内部实现 <code class="docutils literal notranslate"><span class="pre">riscv_sys_send</span></code> ，<code class="docutils literal notranslate"><span class="pre">riscv_sys_send_null</span></code> 等函数，这些函数基本的执行逻辑为通过 <code class="docutils literal notranslate"><span class="pre">ecall</span></code> 指令陷入内核并通过寄存器传递参数。以 <code class="docutils literal notranslate"><span class="pre">seL4_Signal</span></code> 为例，目前默认的实现方法为：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">LIBSEL4_INLINE_FUNC</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">seL4_Signal</span><span class="p">(</span><span class="n">seL4_CPtr</span><span class="w"> </span><span class="n">dest</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">riscv_sys_send_null</span><span class="p">(</span><span class="n">seL4_SysSend</span><span class="p">,</span><span class="w"> </span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="n">seL4_MessageInfo_new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">riscv_sys_send_null</span><span class="p">(</span><span class="n">seL4_Word</span><span class="w"> </span><span class="n">sys</span><span class="p">,</span><span class="w"> </span><span class="n">seL4_Word</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">seL4_Word</span><span class="w"> </span><span class="n">info_arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">register</span><span class="w"> </span><span class="n">seL4_Word</span><span class="w"> </span><span class="n">destptr</span><span class="w"> </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;a0&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">;</span>
<span class="w">    </span><span class="k">register</span><span class="w"> </span><span class="n">seL4_Word</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;a1&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info_arg</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Perform the system call. */</span>
<span class="w">    </span><span class="k">register</span><span class="w"> </span><span class="n">seL4_Word</span><span class="w"> </span><span class="n">scno</span><span class="w"> </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;a7&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys</span><span class="p">;</span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span>
<span class="w">        </span><span class="s">&quot;ecall&quot;</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;+r&quot;</span><span class="p">(</span><span class="n">destptr</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;+r&quot;</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">scno</span><span class="p">)</span>
<span class="w">    </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>相当于和 <code class="docutils literal notranslate"><span class="pre">seL4_Send</span></code> 共用了内核接口，换句话说，可以将 <code class="docutils literal notranslate"><span class="pre">seL4_Signal</span></code> 视为消息长度为空的 <code class="docutils literal notranslate"><span class="pre">seL4_Send</span></code> 。</p>
<p>注意到开关 MCS 参数前后，系统调用的实现方式是不一样的，以 <code class="docutils literal notranslate"><span class="pre">seL4_Poll</span></code> 为例：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">LIBSEL4_INLINE_FUNC</span><span class="w"> </span><span class="n">seL4_MessageInfo_t</span><span class="w"> </span><span class="n">seL4_Poll</span><span class="p">(</span><span class="n">seL4_CPtr</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">seL4_Word</span><span class="w"> </span><span class="o">*</span><span class="n">sender</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_KERNEL_MCS</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">seL4_NBWait</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">sender</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">seL4_NBRecv</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">sender</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
</pre></div>
</div>
<p>内核系统调用处理函数入口为 <code class="docutils literal notranslate"><span class="pre">exception_t</span> <span class="pre">handleSyscall(syscall_t</span> <span class="pre">syscall)</span></code> 。下面分别对不同系统调用的处理进行分析。</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">exception_t</span> <span class="pre">handleInvocation(bool_t</span> <span class="pre">isCall,</span> <span class="pre">bool_t</span> <span class="pre">isBlocking)</span></code> 函数主要用来处理 Send 和 Call 等系统调用：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 获取 a0 和 a1 寄存器中的 cap 和 msg 元信息</span>
<span class="n">seL4_MessageInfo_t</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">messageInfoFromWord</span><span class="p">(</span><span class="n">getRegister</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="n">msgInfoRegister</span><span class="p">));</span>
<span class="n">cptr_t</span><span class="w"> </span><span class="n">cptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getRegister</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="n">capRegister</span><span class="p">);</span>
<span class="c1">// 在当前 cspace 中查找 cptr（权限检查）</span>
<span class="n">lookupCapAndSlot_ret_t</span><span class="w"> </span><span class="n">lu_ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookupCapAndSlot</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="n">cptr</span><span class="p">);</span>
<span class="c1">// 获取 IPC buffer 的起始地址，对 Buffer 的类型和读写权限进行检查</span>
<span class="n">word_t</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookupIPCBuffer</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kr">thread</span><span class="p">);</span>
<span class="c1">// 在 buffer 中遍历 extra caps</span>
<span class="n">exception_t</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookupExtraCaps</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">);</span>
<span class="c1">// 根据 cap 类型进行处理，检查 cap 是否可以发送（CanSend）</span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decodeInvocation</span><span class="p">(</span><span class="n">seL4_MessageInfo_get_label</span><span class="p">(</span><span class="n">info</span><span class="p">),</span><span class="w"> </span><span class="n">length</span><span class="p">,</span>
<span class="w">                          </span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="n">lu_ret</span><span class="p">.</span><span class="n">slot</span><span class="p">,</span><span class="w"> </span><span class="n">lu_ret</span><span class="p">.</span><span class="n">cap</span><span class="p">,</span>
<span class="w">                          </span><span class="n">isBlocking</span><span class="p">,</span><span class="w"> </span><span class="n">isCall</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">void</span> <span class="pre">handleRecv(bool_t</span> <span class="pre">isBlocking)</span></code> 函数主要用来处理 Recv 和 NBRecv 等系统嗲用：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 获取 a0 寄存器中的 cap</span>
<span class="n">cptr_t</span><span class="w"> </span><span class="n">cptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getRegister</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="n">capRegister</span><span class="p">);</span>
<span class="c1">// 在当前 cspace 中查找 cptr（权限检查）</span>
<span class="n">lookupCapAndSlot_ret_t</span><span class="w"> </span><span class="n">lu_ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookupCapAndSlot</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="n">cptr</span><span class="p">);</span>
<span class="c1">// 根据 cap 类型进行处理</span>
<span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">cap_get_capType</span><span class="p">(</span><span class="n">lu_ret</span><span class="p">.</span><span class="n">cap</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">cap_endpoint_cap</span><span class="p">:</span>
<span class="w">    </span><span class="c1">// 检查 ep 是否可以接收（CanReceive）</span>
<span class="w">    </span><span class="n">receiveIPC</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="n">lu_ret</span><span class="p">.</span><span class="n">cap</span><span class="p">,</span><span class="w"> </span><span class="n">isBlocking</span><span class="p">);</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">cap_notification_cap</span><span class="p">:</span>
<span class="w">    </span><span class="c1">// 检查 cap 是否对应该线程绑定的 ntfn</span>
<span class="w">    </span><span class="n">receiveSignal</span><span class="p">(</span><span class="n">NODE_STATE</span><span class="p">(</span><span class="n">ksCurThread</span><span class="p">),</span><span class="w"> </span><span class="n">lu_ret</span><span class="p">.</span><span class="n">cap</span><span class="p">,</span><span class="w"> </span><span class="n">isBlocking</span><span class="p">);</span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sel4test">
<h2><a class="reference external" href="https://github.com/seL4/sel4test/blob/master/docs/design.md">seL4test</a><a class="headerlink" href="#sel4test" title="永久链接至标题">#</a></h2>
<p>root 是 sel4test-driver ，启动时获取 <code class="docutils literal notranslate"><span class="pre">seL4_Bootinfo_t</span></code> ，为测例的运行提供环境。bootstrap 运行环境主要是为了测试创建进程和与其通信的功能是否正常。root 通过 linker section 来在运行时选择测例，可以通过字符串匹配在编译期对测例进行选择。测例是依次运行的，root 可以选择是否在测例运行失败后中止测试。</p>
<p>sel4test-driver 运行流程：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="o">-&gt;</span>
  <span class="n">main_continued</span> <span class="o">-&gt;</span>
    <span class="n">sel4test_run_tests</span> <span class="o">-&gt;</span>
      <span class="n">test_types</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">run_test</span><span class="p">(</span><span class="n">tests</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>sel4test_run_tests 根据 <code class="docutils literal notranslate"><span class="pre">__start__test_type</span></code> 到 <code class="docutils literal notranslate"><span class="pre">__stop__test_type</span></code> 加载 <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">test_type</span></code> 信息，对 test 进行过滤后依次运行每个 test （不同 test_type 可以有多个 test）。</p>
<p>ipc.c 测例集中的测例大部分是基于 <code class="docutils literal notranslate"><span class="pre">test_ipc_pair</span></code> 这个函数，下面对代码中的一些关键片段进行分析：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 分配 endpoint_cap</span>
<span class="n">seL4_CPtr</span><span class="w"> </span><span class="n">ep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vka_alloc_endpoint_leaky</span><span class="p">(</span><span class="n">vka</span><span class="p">);</span>
<span class="c1">// 分配 reply_cap</span>
<span class="n">seL4_CPtr</span><span class="w"> </span><span class="n">a_reply</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vka_alloc_reply_leaky</span><span class="p">(</span><span class="n">vka</span><span class="p">);</span>
<span class="c1">// 将当前进程的 cspace 复制到新创建的进程，目的是为了让 sender 和 receiver 间能共享 endpoint</span>
<span class="n">cspacepath_t</span><span class="w"> </span><span class="n">path</span><span class="p">;</span>
<span class="n">create_helper_process</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">thread_a</span><span class="p">);</span>
<span class="n">vka_cspace_make_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">vka</span><span class="p">,</span><span class="w"> </span><span class="n">ep</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
<span class="n">thread_a_arg0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sel4utils_copy_path_to_process</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_a</span><span class="p">.</span><span class="n">process</span><span class="p">,</span><span class="w"> </span><span class="n">path</span><span class="p">);</span>
<span class="c1">// 线程默认共享 cspace ，所以可以直接创建</span>
<span class="n">create_helper_thread</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">thread_a</span><span class="p">);</span>
<span class="c1">// 设置 sender 的调度优先级</span>
<span class="n">set_helper_priority</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">thread_a</span><span class="p">,</span><span class="w"> </span><span class="n">sender_prio</span><span class="p">);</span>
<span class="c1">// 绑定 sender 运行的核</span>
<span class="n">set_helper_affinity</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">thread_a</span><span class="p">,</span><span class="w"> </span><span class="n">core_a</span><span class="p">);</span>
<span class="c1">// 开始执行线程（进程）</span>
<span class="n">start_helper</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">thread_a</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">helper_fn_t</span><span class="p">)</span><span class="w"> </span><span class="n">fa</span><span class="p">,</span><span class="w"> </span><span class="n">thread_a_arg0</span><span class="p">,</span><span class="w"> </span><span class="n">start_number</span><span class="p">,</span>
<span class="w">             </span><span class="n">thread_a_reply</span><span class="p">,</span><span class="w"> </span><span class="n">nbwait_should_wait</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="sel4-riscv-vmm">
<h2><a class="reference external" href="https://github.com/SEL4PROJ/sel4_riscv_vmm/blob/master/src/vmm.c">sel4-riscv-vmm</a><a class="headerlink" href="#sel4-riscv-vmm" title="永久链接至标题">#</a></h2>
<p>该项目还处于试验阶段，支持 v0.6.1 RISC-V Hypervisor 指令扩展。</p>
<p><strong>irq_server_node</strong></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">irq_server_node</span><span class="w"> </span><span class="p">{</span>
<span class="c1">/// Information about the IRQ that is assigned to each badge bit</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">irq_data</span><span class="w"> </span><span class="n">irqs</span><span class="p">[</span><span class="n">NIRQS_PER_NODE</span><span class="p">];</span>
<span class="c1">/// The notification object that IRQs arrive on</span>
<span class="w">    </span><span class="n">seL4_CPtr</span><span class="w"> </span><span class="n">notification</span><span class="p">;</span>
<span class="c1">/// A mask for the badge. All set bits within the badge are treated as reserved.</span>
<span class="w">    </span><span class="n">seL4_Word</span><span class="w"> </span><span class="n">badge_mask</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_server_node</span></code> 维护由该 node 处理的 irq (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span></code>) ，一个 irq 对应 badge 的一位，通过 Notification 从接收 irq ，由 <code class="docutils literal notranslate"><span class="pre">irq_server_node_handle_irq</span></code> 根据 badge 通过调用预先注册的 handler 对所有收到的 irq 进行处理。<code class="docutils literal notranslate"><span class="pre">irq_bind</span></code> 函数根据 irq 序号分配 irq_cap ，并设置 notification_cap 中 badge 的对应位，最后将该 notification_cap 绑定到 irq_cap 。<code class="docutils literal notranslate"><span class="pre">irq_server_node_register_irq</span></code> 注册由该 node 处理的 irq 和 handler。</p>
<p><strong>irq_server_thread</strong></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">irq_server_thread</span><span class="w"> </span><span class="p">{</span>
<span class="c1">/// IRQ data which this thread is responsible for</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">irq_server_node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">;</span>
<span class="c1">/// A synchronous endpoint to deliver IRQ messages to.</span>
<span class="w">    </span><span class="n">seL4_CPtr</span><span class="w"> </span><span class="n">delivery_sep</span><span class="p">;</span>
<span class="c1">/// The label that should be assigned to outgoing synchronous messages.</span>
<span class="w">    </span><span class="n">seL4_Word</span><span class="w"> </span><span class="n">label</span><span class="p">;</span>
<span class="c1">/// Thread data</span>
<span class="w">    </span><span class="n">sel4utils_thread_t</span><span class="w"> </span><span class="kr">thread</span><span class="p">;</span>
<span class="c1">/// notification object data</span>
<span class="w">    </span><span class="n">vka_object_t</span><span class="w"> </span><span class="n">notification</span><span class="p">;</span>
<span class="c1">/// Linked list chain</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">irq_server_thread</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">irq_server_thread_new</span></code> 初始化内核结构，并创建 irqserver 线程，入口为 <code class="docutils literal notranslate"><span class="pre">_irq_thread_entry</span></code> ，其中 delivery_sep 为可选结构，用来向其他 ep 发送 irq 信息。<code class="docutils literal notranslate"><span class="pre">_irq_thread_entry</span></code> 轮询 notification 消息来获取中断，如果未注册用于同步发送消息的 sep 就直接调用 handler 。</p>
<p>这部分函数比较关键，感觉用户态中断可以支持这部分功能。</p>
<p><strong>irq_server</strong></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">irq_server</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">seL4_CPtr</span><span class="w"> </span><span class="n">delivery_ep</span><span class="p">;</span>
<span class="w">    </span><span class="n">vka_object_t</span><span class="w"> </span><span class="n">reply</span><span class="p">;</span>
<span class="w">    </span><span class="n">seL4_Word</span><span class="w"> </span><span class="n">label</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">max_irqs</span><span class="p">;</span>
<span class="w">    </span><span class="n">vspace_t</span><span class="w"> </span><span class="o">*</span><span class="n">vspace</span><span class="p">;</span>
<span class="w">    </span><span class="n">seL4_CPtr</span><span class="w"> </span><span class="n">cspace</span><span class="p">;</span>
<span class="w">    </span><span class="n">vka_t</span><span class="o">*</span><span class="w"> </span><span class="n">vka</span><span class="p">;</span>
<span class="w">    </span><span class="n">seL4_Word</span><span class="w"> </span><span class="n">thread_priority</span><span class="p">;</span>
<span class="w">    </span><span class="n">simple_t</span><span class="w"> </span><span class="n">simple</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">irq_server_thread</span><span class="w"> </span><span class="o">*</span><span class="n">server_threads</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">vm</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* affinity of the server threads */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">affinity</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">irq_server_handle_irq_ipc</span></code> 用于其他线程处理 irqserver 以 IPC 形式转发的 irq 信息。函数 <code class="docutils literal notranslate"><span class="pre">irq_server_register_irq</span></code> 先遍历当前 irq nodes 并将 irq 委托给其中一个 thread ，否则创建新的 thread 。函数 <code class="docutils literal notranslate"><span class="pre">irq_server_new</span></code> 初始化 server 结构，如果需要处理默认指定的 irq ，则根据传入的 irq 数量创建 thread 。</p>
</div>
</div>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          <a class="prev-page" href="daily.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">阅读笔记</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, Kaifu Tian
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            目录
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">seL4</a><ul>
<li><a class="reference internal" href="#tutorial">Tutorial</a></li>
<li><a class="reference internal" href="#hardware">Hardware</a></li>
<li><a class="reference internal" href="#capability">Capability</a></li>
<li><a class="reference internal" href="#tcb">TCB</a></li>
<li><a class="reference internal" href="#mcs">MCS</a></li>
<li><a class="reference internal" href="#ipc">IPC</a></li>
<li><a class="reference internal" href="#notification">Notification</a></li>
<li><a class="reference internal" href="#irq">IRQ</a></li>
<li><a class="reference internal" href="#boot">Boot</a></li>
<li><a class="reference internal" href="#syscalls">Syscalls</a></li>
<li><a class="reference internal" href="#sel4test">seL4test</a></li>
<li><a class="reference internal" href="#sel4-riscv-vmm">sel4-riscv-vmm</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script kind="utterances">

    var commentsRunWhenDOMLoaded = cb => {
    if (document.readyState != 'loading') {
        cb()
    } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', cb)
    } else {
        document.attachEvent('onreadystatechange', function() {
        if (document.readyState == 'complete') cb()
        })
    }
}

var addUtterances = () => {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "https://utteranc.es/client.js";
    script.async = "async";

    script.setAttribute("repo", "tkf2019/Blog");
    script.setAttribute("issue-term", "pathname");
    script.setAttribute("theme", "github-light");
    script.setAttribute("label", "comments");
    script.setAttribute("crossorigin", "anonymous");

    sections = document.querySelectorAll("div.section");
    if (sections !== null) {
        section = sections[sections.length-1];
        section.appendChild(script);
    }
}
commentsRunWhenDOMLoaded(addUtterances);
</script>
    <script src="../_static/translations.js"></script>
    <script src="../_static/design-tabs.js"></script>
    </body>
</html>